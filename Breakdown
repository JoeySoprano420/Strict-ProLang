ğŸ“˜ Strict Language v6 â€” Generics, Templates & Metaprogramming
1. ğŸ§© Generics (Parametric Types)
Class Box<T>
    Let value

    Func Init(v)
        value = v
    End

    Func Get()
        Return value
    End
End

Let intBox = New Box<Int>(42)
Print intBox.Get()

Let strBox = New Box<String>("Hello")
Print strBox.Get()


ğŸ”— DGM Mapping

language.derive (A3) â†’ template instantiation

language.infer (A8) â†’ infer type parameter

language.replace (AA) â†’ specialize with concrete type

2. ğŸ— Templates (Compile-Time Expansion)
Template Max<T>(a, b)
    If a > b Then
        Return a
    Else
        Return b
    End
End

Print Call Max<Int>(10, 7)
Print Call Max<String>("apple", "zebra")


ğŸ”— DGM Mapping

language.inline (A0) â†’ force inlining

language.expand (A1) â†’ expand template body

language.fold (A2) â†’ constant-fold where possible

3. ğŸŒ€ Compile-Time Evaluation (CTE)
Const SIZE = 4 * 8

Let arr = Array.New<SIZE>()


ğŸ”— DGM Mapping

language.fold (A2) â†’ fold constants into IR

language.trace (A5) â†’ compile-time debug hooks

4. ğŸ›  Metaprogramming Macros
Macro Repeat<N>(code)
    For i = 1..N Then
        Expand code
    End
End

Repeat<3>( Print "Hello" )


Expands at compile time â†’

Print "Hello"
Print "Hello"
Print "Hello"


ğŸ”— DGM Mapping

language.macro (A4) â†’ macro define

language.expand (A1) â†’ macro expansion

language.pragma (BA) â†’ compiler directives

5. ğŸ”§ Type Inference & Auto
Let a = 42        -- inferred as Int
Let b = "world"   -- inferred as String


ğŸ”— DGM Mapping

language.infer (A8) â†’ infer at IR lowering

language.echo (A6) â†’ debug inferred type if requested

6. ğŸ–‡ Metaprogramming with Reflection
Reflect Person*Struct*

01 alloca x
01 alloca y
03 store 5 -> x
03 store input -> y

15 icmp x > y
30 br cond_true, cond_end

15 icmp y < 4
30 br cond_true, cond_end

17 add x, y -> tmp
15 icmp tmp in 0..8
30 br cond_true, cond_end

95 match.begin
96 match.case y=1..5
A6 language.echo "few"
96 match.case y=6..8
A6 language.echo "many"
96 match.case y=0
A6 language.echo "none"
96 match.case y<0
A6 language.echo "negative"
97 match.end

33 ret



*DGM*

01 alloca x
01 alloca y
03 store 5 -> x
03 store input -> y

15 icmp x > y
30 br cond_true, cond_end

15 icmp y < 4
30 br cond_true, cond_end

17 add x, y -> tmp
15 icmp tmp in 0..8
30 br cond_true, cond_end

95 match.begin
96 match.case y=1..5
A6 language.echo "few"
96 match.case y=6..8
A6 language.echo "many"
96 match.case y=0
A6 language.echo "none"
96 match.case y<0
A6 language.echo "negative"
97 match.end

33 ret


*LLVM*

%x = alloca i32
%y = alloca i32
store i32 5, i32* %x
%inp = call i32 @get_input()
store i32 %inp, i32* %y

%valx = load i32, i32* %x
%valy = load i32, i32* %y
%cmp1 = icmp sgt i32 %valx, %valy
br i1 %cmp1, label %L1, label %Lend

L1:
%cmp2 = icmp slt i32 %valy, 4
br i1 %cmp2, label %L2, label %Lend

L2:
%sum = add i32 %valx, %valy
%inrange = icmp sge i32 %sum, 0
%inrange2 = icmp sle i32 %sum, 8
%ok = and i1 %inrange, %inrange2
br i1 %ok, label %L3, label %Lend

L3:
; match cases
switch i32 %valy, label %default [
  i32 1, label %caseFew
  i32 2, label %caseFew
  i32 3, label %caseFew
  i32 4, label %caseFew
  i32 5, label %caseFew
  i32 6, label %caseMany
  i32 7, label %caseMany
  i32 8, label %caseMany
  i32 0, label %caseNone
]

caseFew:
  call void @puts(i8* getelementptr ([4 x i8], [4 x i8]* @.few, i32 0, i32 0))
  br label %Lend
caseMany:
  call void @puts(i8* getelementptr ([5 x i8], [5 x i8]* @.many, i32 0, i32 0))
  br label %Lend
caseNone:
  call void @puts(i8* getelementptr ([5 x i8], [5 x i8]* @.none, i32 0, i32 0))
  br label %Lend
default:
  %neg = icmp slt i32 %valy, 0
  br i1 %neg, label %caseNeg, label %Lend
caseNeg:
  call void @puts(i8* getelementptr ([9 x i8], [9 x i8]* @.negative, i32 0, i32 0))
  br label %Lend

Lend:
ret void


*NASM x64 Output*

; x=5, y=input
mov DWORD [x], 5
call get_input
mov DWORD [y], eax

; if x > y
mov eax, [x]
cmp eax, [y]
jle .Lend

; if y < 4
cmp [y], 4
jge .Lend

; if x+y in 0..8
mov eax, [x]
add eax, [y]
cmp eax, 0
jl .Lend
cmp eax, 8
jg .Lend

; match cases
cmp [y], 0
je .caseNone
jl .caseNeg
cmp [y], 5
jle .caseFew
cmp [y], 8
jle .caseMany
jmp .Lend

ğŸ“˜ Strict Language v3 â€” Full Syntax
1. Declarations
Let x = 5
Let y = Input
Let name = "StrictLang"

2. Expressions
x = x + 1
y = y * 2
z = (x + y) * 3

3. Conditionals
If x > y Then
    Print "x greater"
Else
    Print "y greater or equal"
End

4. Loops
For i = 1..10 Then
    Print i
End

While x < 100 Then
    x = x + 1
End

5. Functions
Func Square(n)
    Return n * n
End

Let result = Call Square(7)
Print result

6. Data Structures
Let nums = [1, 2, 3]
List.Append nums, 4
List.Remove nums, 2
Array.Store nums, 1, 99

7. Pattern Matching
Match y
    Case 0: Print "none"
    Case 1..5: Print "few"
    Case 6..8: Print "many"
    Case <0: Print "negative"
End

8. Safety Ops (50â€“7B DGM region)
Safe.Add x, y      -- guarded ADD
Safe.Sub x, y
Safe.Div x, y

9. Parallelism + Future Extensions (A0â€“BB CIAM ops)
Future Task1
    Print "running async"
End

ğŸ“˜ Strict Language v4 â€” Expanded Features
1. ğŸ“¦ Modules & Imports

Strict supports modular programming. Each .strict file is a module.

Module Math

Func Add(a, b)
    Return a + b
End

Export Add


Usage:

Import Math

Let z = Call Math.Add(3, 4)
Print z


ğŸ”— DGM Mapping:

language.link (A7) â†’ dynamic linking of module functions.

language.open (B4) / language.close (B5) â†’ load/unload module files.

2. ğŸ“ Macros (CIAM Extensions)

Strict integrates Contextual Inference Abstraction Macros (CIAM).

Macro Double(x)
    Return x + x
End

Let y = Double(7)
Print y


ğŸ”— DGM Mapping:

language.macro (A4)

language.expand (A1)

language.fold (A2)

3. âš¡ Concurrency & Futures
Future Task1
    Print "Running async"
End

Parallel
    Task1
    Print "In main thread"
End

ğŸ“˜ Strict Language v5 â€” Object-Oriented Expansion
1. ğŸ› Classes & Objects
Class Person
    Let name
    Let age

    Func Init(n, a)
        name = n
        age = a
    End

    Func Greet()
        Print "Hello, my name is " + name
    End
End


Usage:

Let p = New Person("Ana", 30)
Call p.Greet()


ğŸ”— DGM Mapping:

nest.enter (8B) â†’ enter class scope

derive.child (91) â†’ create object instance

pair.create (93) â†’ object + vtable pairing

array.store (87) â†’ store fields

2. ğŸ§¬ Inheritance
Class Student : Person
    Let major

    Func Init(n, a, m)
        Call Parent.Init(n, a)
        major = m
    End

    Func Greet()
        Print "I am " + name + ", studying " + major
    End
End


Usage:

Let s = New Student("Bob", 21, "Math")
Call s.Greet()


ğŸ”— DGM Mapping:

derive.parent (92) â†’ inherit fields & methods

pair.split (94) â†’ override vs parent methods

3. ğŸ” Encapsulation & Access
Class BankAccount
    Private Let balance = 0

    Func Deposit(amount)
        balance = balance + amount
    End

    Func GetBalance()
        Return balance
    End
End


Usage:

Let acc = New BankAccount()
Call acc.Deposit(100)
Print acc.GetBalance()


ğŸ”— DGM Mapping:

group.spawn (88) â†’ encapsulated storage

group.merge (89) â†’ method access binding

group.split (8A) â†’ private vs public separation

4. ğŸŒ² Polymorphism (Virtual Dispatch)
Class Animal
    Func Speak()
        Print "..."
    End
End

Class Dog : Animal
    Func Speak()
        Print "Woof!"
    End
End

Class Cat : Animal
    Func Speak()
        Print "Meow!"
    End
End

Let pets = [New Dog(), New Cat()]
For each in pets Then
    Call each.Speak()
End


ğŸ”— DGM Mapping:

phi (38) â†’ SSA merge of object types

select (39) â†’ choose method dynamically

language.wrap (B1) â†’ vtable call dispatch

5. ğŸ›¡ Interfaces / Abstract Classes
Interface Shape
    Func Area()
End

Class Circle : Shape
    Let r
    Func Init(radius)
        r = radius
    End
    Func Area()
        Return 3.14 * r * r
    End
End


ğŸ”— DGM Mapping:

language.enclose (B3) â†’ interface contract scope

language.assert (7B) â†’ enforce method implementation

âš™ï¸ Compiler Additions
1. Class Handling

nest.enter / nest.exit mark class scope

Members lowered to array slots

Methods bound as pairs (pair.create)

2. Inheritance

derive.parent copies parent layout

Method overrides use pair.split

3. Object Allocation
// New Student("Bob",21,"Math")
emit("91 derive.child Student")
emit("87 array.store obj.name, \"Bob\"")
emit("87 array.store obj.age, 21")
emit("87 array.store obj.major, \"Math\"")

ğŸ–¥ Example OOP Strict Program
Class Person
    Let name
    Func Init(n)
        name = n
    End
    Func Greet()
        Print "Hello, I am " + name
    End
End

Class Student : Person
    Let major
    Func Init(n, m)
        Call Parent.Init(n)
        major = m
    End
    Func Greet()
        Print name + " studies " + major
    End
End

Let s = New Student("Ana", "Physics")
Call s.Greet()

ğŸ“˜ Strict Language v6 â€” Generics, Templates & Metaprogramming
1. ğŸ§© Generics (Parametric Types)
Class Box<T>
    Let value

    Func Init(v)
        value = v
    End

    Func Get()
        Return value
    End
End

Let intBox = New Box<Int>(42)
Print intBox.Get()

Let strBox = New Box<String>("Hello")
Print strBox.Get()


ğŸ”— DGM Mapping

language.derive (A3) â†’ template instantiation

language.infer (A8) â†’ infer type parameter

language.replace (AA) â†’ specialize with concrete type

2. ğŸ— Templates (Compile-Time Expansion)
Template Max<T>(a, b)
    If a > b Then
        Return a
    Else
        Return b
    End
End

Print Call Max<Int>(10, 7)
Print Call Max<String>("apple", "zebra")


ğŸ”— DGM Mapping

language.inline (A0) â†’ force inlining

language.expand (A1) â†’ expand template body

language.fold (A2) â†’ constant-fold where possible

3. ğŸŒ€ Compile-Time Evaluation (CTE)
Const SIZE = 4 * 8

Let arr = Array.New<SIZE>()


ğŸ”— DGM Mapping

language.fold (A2) â†’ fold constants into IR

language.trace (A5) â†’ compile-time debug hooks

4. ğŸ›  Metaprogramming Macros
Macro Repeat<N>(code)
    For i = 1..N Then
        Expand code
    End
End

Repeat<3>( Print "Hello" )


Expands at compile time â†’

Print "Hello"
Print "Hello"
Print "Hello"


ğŸ”— DGM Mapping

language.macro (A4) â†’ macro define

language.expand (A1) â†’ macro expansion

language.pragma (BA) â†’ compiler directives

5. ğŸ”§ Type Inference & Auto
Let a = 42        -- inferred as Int
Let b = "world"   -- inferred as String


ğŸ”— DGM Mapping

language.infer (A8) â†’ infer at IR lowering

language.echo (A6) â†’ debug inferred type if requested

6. ğŸ–‡ Metaprogramming with Reflection
Reflect Person

