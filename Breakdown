*Struct*

01 alloca x
01 alloca y
03 store 5 -> x
03 store input -> y

15 icmp x > y
30 br cond_true, cond_end

15 icmp y < 4
30 br cond_true, cond_end

17 add x, y -> tmp
15 icmp tmp in 0..8
30 br cond_true, cond_end

95 match.begin
96 match.case y=1..5
A6 language.echo "few"
96 match.case y=6..8
A6 language.echo "many"
96 match.case y=0
A6 language.echo "none"
96 match.case y<0
A6 language.echo "negative"
97 match.end

33 ret



*DGM*

01 alloca x
01 alloca y
03 store 5 -> x
03 store input -> y

15 icmp x > y
30 br cond_true, cond_end

15 icmp y < 4
30 br cond_true, cond_end

17 add x, y -> tmp
15 icmp tmp in 0..8
30 br cond_true, cond_end

95 match.begin
96 match.case y=1..5
A6 language.echo "few"
96 match.case y=6..8
A6 language.echo "many"
96 match.case y=0
A6 language.echo "none"
96 match.case y<0
A6 language.echo "negative"
97 match.end

33 ret


*LLVM*

%x = alloca i32
%y = alloca i32
store i32 5, i32* %x
%inp = call i32 @get_input()
store i32 %inp, i32* %y

%valx = load i32, i32* %x
%valy = load i32, i32* %y
%cmp1 = icmp sgt i32 %valx, %valy
br i1 %cmp1, label %L1, label %Lend

L1:
%cmp2 = icmp slt i32 %valy, 4
br i1 %cmp2, label %L2, label %Lend

L2:
%sum = add i32 %valx, %valy
%inrange = icmp sge i32 %sum, 0
%inrange2 = icmp sle i32 %sum, 8
%ok = and i1 %inrange, %inrange2
br i1 %ok, label %L3, label %Lend

L3:
; match cases
switch i32 %valy, label %default [
  i32 1, label %caseFew
  i32 2, label %caseFew
  i32 3, label %caseFew
  i32 4, label %caseFew
  i32 5, label %caseFew
  i32 6, label %caseMany
  i32 7, label %caseMany
  i32 8, label %caseMany
  i32 0, label %caseNone
]

caseFew:
  call void @puts(i8* getelementptr ([4 x i8], [4 x i8]* @.few, i32 0, i32 0))
  br label %Lend
caseMany:
  call void @puts(i8* getelementptr ([5 x i8], [5 x i8]* @.many, i32 0, i32 0))
  br label %Lend
caseNone:
  call void @puts(i8* getelementptr ([5 x i8], [5 x i8]* @.none, i32 0, i32 0))
  br label %Lend
default:
  %neg = icmp slt i32 %valy, 0
  br i1 %neg, label %caseNeg, label %Lend
caseNeg:
  call void @puts(i8* getelementptr ([9 x i8], [9 x i8]* @.negative, i32 0, i32 0))
  br label %Lend

Lend:
ret void


*NASM x64 Output*

; x=5, y=input
mov DWORD [x], 5
call get_input
mov DWORD [y], eax

; if x > y
mov eax, [x]
cmp eax, [y]
jle .Lend

; if y < 4
cmp [y], 4
jge .Lend

; if x+y in 0..8
mov eax, [x]
add eax, [y]
cmp eax, 0
jl .Lend
cmp eax, 8
jg .Lend

; match cases
cmp [y], 0
je .caseNone
jl .caseNeg
cmp [y], 5
jle .caseFew
cmp [y], 8
jle .caseMany
jmp .Lend

ðŸ“˜ Strict Language v3 â€” Full Syntax
1. Declarations
Let x = 5
Let y = Input
Let name = "StrictLang"

2. Expressions
x = x + 1
y = y * 2
z = (x + y) * 3

3. Conditionals
If x > y Then
    Print "x greater"
Else
    Print "y greater or equal"
End

4. Loops
For i = 1..10 Then
    Print i
End

While x < 100 Then
    x = x + 1
End

5. Functions
Func Square(n)
    Return n * n
End

Let result = Call Square(7)
Print result

6. Data Structures
Let nums = [1, 2, 3]
List.Append nums, 4
List.Remove nums, 2
Array.Store nums, 1, 99

7. Pattern Matching
Match y
    Case 0: Print "none"
    Case 1..5: Print "few"
    Case 6..8: Print "many"
    Case <0: Print "negative"
End

8. Safety Ops (50â€“7B DGM region)
Safe.Add x, y      -- guarded ADD
Safe.Sub x, y
Safe.Div x, y

9. Parallelism + Future Extensions (A0â€“BB CIAM ops)
Future Task1
    Print "running async"
End

ðŸ“˜ Strict Language v4 â€” Expanded Features
1. ðŸ“¦ Modules & Imports

Strict supports modular programming. Each .strict file is a module.

Module Math

Func Add(a, b)
    Return a + b
End

Export Add


Usage:

Import Math

Let z = Call Math.Add(3, 4)
Print z


ðŸ”— DGM Mapping:

language.link (A7) â†’ dynamic linking of module functions.

language.open (B4) / language.close (B5) â†’ load/unload module files.

2. ðŸ“ Macros (CIAM Extensions)

Strict integrates Contextual Inference Abstraction Macros (CIAM).

Macro Double(x)
    Return x + x
End

Let y = Double(7)
Print y


ðŸ”— DGM Mapping:

language.macro (A4)

language.expand (A1)

language.fold (A2)

3. âš¡ Concurrency & Futures
Future Task1
    Print "Running async"
End

Parallel
    Task1
    Print "In main thread"
End

ðŸ“˜ Strict Language v5 â€” Object-Oriented Expansion
1. ðŸ› Classes & Objects
Class Person
    Let name
    Let age

    Func Init(n, a)
        name = n
        age = a
    End

    Func Greet()
        Print "Hello, my name is " + name
    End
End


Usage:

Let p = New Person("Ana", 30)
Call p.Greet()


ðŸ”— DGM Mapping:

nest.enter (8B) â†’ enter class scope

derive.child (91) â†’ create object instance

pair.create (93) â†’ object + vtable pairing

array.store (87) â†’ store fields

2. ðŸ§¬ Inheritance
Class Student : Person
    Let major

    Func Init(n, a, m)
        Call Parent.Init(n, a)
        major = m
    End

    Func Greet()
        Print "I am " + name + ", studying " + major
    End
End


Usage:

Let s = New Student("Bob", 21, "Math")
Call s.Greet()


ðŸ”— DGM Mapping:

derive.parent (92) â†’ inherit fields & methods

pair.split (94) â†’ override vs parent methods

3. ðŸ” Encapsulation & Access
Class BankAccount
    Private Let balance = 0

    Func Deposit(amount)
        balance = balance + amount
    End

    Func GetBalance()
        Return balance
    End
End


Usage:

Let acc = New BankAccount()
Call acc.Deposit(100)
Print acc.GetBalance()


ðŸ”— DGM Mapping:

group.spawn (88) â†’ encapsulated storage

group.merge (89) â†’ method access binding

group.split (8A) â†’ private vs public separation

4. ðŸŒ² Polymorphism (Virtual Dispatch)
Class Animal
    Func Speak()
        Print "..."
    End
End

Class Dog : Animal
    Func Speak()
        Print "Woof!"
    End
End

Class Cat : Animal
    Func Speak()
        Print "Meow!"
    End
End

Let pets = [New Dog(), New Cat()]
For each in pets Then
    Call each.Speak()
End


ðŸ”— DGM Mapping:

phi (38) â†’ SSA merge of object types

select (39) â†’ choose method dynamically

language.wrap (B1) â†’ vtable call dispatch

5. ðŸ›¡ Interfaces / Abstract Classes
Interface Shape
    Func Area()
End

Class Circle : Shape
    Let r
    Func Init(radius)
        r = radius
    End
    Func Area()
        Return 3.14 * r * r
    End
End


ðŸ”— DGM Mapping:

language.enclose (B3) â†’ interface contract scope

language.assert (7B) â†’ enforce method implementation

âš™ï¸ Compiler Additions
1. Class Handling

nest.enter / nest.exit mark class scope

Members lowered to array slots

Methods bound as pairs (pair.create)

2. Inheritance

derive.parent copies parent layout

Method overrides use pair.split

3. Object Allocation
// New Student("Bob",21,"Math")
emit("91 derive.child Student")
emit("87 array.store obj.name, \"Bob\"")
emit("87 array.store obj.age, 21")
emit("87 array.store obj.major, \"Math\"")

ðŸ–¥ Example OOP Strict Program
Class Person
    Let name
    Func Init(n)
        name = n
    End
    Func Greet()
        Print "Hello, I am " + name
    End
End

Class Student : Person
    Let major
    Func Init(n, m)
        Call Parent.Init(n)
        major = m
    End
    Func Greet()
        Print name + " studies " + major
    End
End

Let s = New Student("Ana", "Physics")
Call s.Greet()

