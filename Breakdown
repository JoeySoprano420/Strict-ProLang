*Struct*

01 alloca x
01 alloca y
03 store 5 -> x
03 store input -> y

15 icmp x > y
30 br cond_true, cond_end

15 icmp y < 4
30 br cond_true, cond_end

17 add x, y -> tmp
15 icmp tmp in 0..8
30 br cond_true, cond_end

95 match.begin
96 match.case y=1..5
A6 language.echo "few"
96 match.case y=6..8
A6 language.echo "many"
96 match.case y=0
A6 language.echo "none"
96 match.case y<0
A6 language.echo "negative"
97 match.end

33 ret



*DGM*

01 alloca x
01 alloca y
03 store 5 -> x
03 store input -> y

15 icmp x > y
30 br cond_true, cond_end

15 icmp y < 4
30 br cond_true, cond_end

17 add x, y -> tmp
15 icmp tmp in 0..8
30 br cond_true, cond_end

95 match.begin
96 match.case y=1..5
A6 language.echo "few"
96 match.case y=6..8
A6 language.echo "many"
96 match.case y=0
A6 language.echo "none"
96 match.case y<0
A6 language.echo "negative"
97 match.end

33 ret


*LLVM*

%x = alloca i32
%y = alloca i32
store i32 5, i32* %x
%inp = call i32 @get_input()
store i32 %inp, i32* %y

%valx = load i32, i32* %x
%valy = load i32, i32* %y
%cmp1 = icmp sgt i32 %valx, %valy
br i1 %cmp1, label %L1, label %Lend

L1:
%cmp2 = icmp slt i32 %valy, 4
br i1 %cmp2, label %L2, label %Lend

L2:
%sum = add i32 %valx, %valy
%inrange = icmp sge i32 %sum, 0
%inrange2 = icmp sle i32 %sum, 8
%ok = and i1 %inrange, %inrange2
br i1 %ok, label %L3, label %Lend

L3:
; match cases
switch i32 %valy, label %default [
  i32 1, label %caseFew
  i32 2, label %caseFew
  i32 3, label %caseFew
  i32 4, label %caseFew
  i32 5, label %caseFew
  i32 6, label %caseMany
  i32 7, label %caseMany
  i32 8, label %caseMany
  i32 0, label %caseNone
]

caseFew:
  call void @puts(i8* getelementptr ([4 x i8], [4 x i8]* @.few, i32 0, i32 0))
  br label %Lend
caseMany:
  call void @puts(i8* getelementptr ([5 x i8], [5 x i8]* @.many, i32 0, i32 0))
  br label %Lend
caseNone:
  call void @puts(i8* getelementptr ([5 x i8], [5 x i8]* @.none, i32 0, i32 0))
  br label %Lend
default:
  %neg = icmp slt i32 %valy, 0
  br i1 %neg, label %caseNeg, label %Lend
caseNeg:
  call void @puts(i8* getelementptr ([9 x i8], [9 x i8]* @.negative, i32 0, i32 0))
  br label %Lend

Lend:
ret void


*NASM x64 Output*

; x=5, y=input
mov DWORD [x], 5
call get_input
mov DWORD [y], eax

; if x > y
mov eax, [x]
cmp eax, [y]
jle .Lend

; if y < 4
cmp [y], 4
jge .Lend

; if x+y in 0..8
mov eax, [x]
add eax, [y]
cmp eax, 0
jl .Lend
cmp eax, 8
jg .Lend

; match cases
cmp [y], 0
je .caseNone
jl .caseNeg
cmp [y], 5
jle .caseFew
cmp [y], 8
jle .caseMany
jmp .Lend

ðŸ“˜ Strict Language v3 â€” Full Syntax
1. Declarations
Let x = 5
Let y = Input
Let name = "StrictLang"

2. Expressions
x = x + 1
y = y * 2
z = (x + y) * 3

3. Conditionals
If x > y Then
    Print "x greater"
Else
    Print "y greater or equal"
End

4. Loops
For i = 1..10 Then
    Print i
End

While x < 100 Then
    x = x + 1
End

5. Functions
Func Square(n)
    Return n * n
End

Let result = Call Square(7)
Print result

6. Data Structures
Let nums = [1, 2, 3]
List.Append nums, 4
List.Remove nums, 2
Array.Store nums, 1, 99

7. Pattern Matching
Match y
    Case 0: Print "none"
    Case 1..5: Print "few"
    Case 6..8: Print "many"
    Case <0: Print "negative"
End

8. Safety Ops (50â€“7B DGM region)
Safe.Add x, y      -- guarded ADD
Safe.Sub x, y
Safe.Div x, y

9. Parallelism + Future Extensions (A0â€“BB CIAM ops)
Future Task1
    Print "running async"
End
